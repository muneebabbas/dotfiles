{ dotfilesSource ? null }:

{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.programs.zsh-dotfiles;

  # Helper to create symlink for local clone mode
  mkUserSymlink = username: userCfg:
    let
      homeDir = config.users.users.${username}.home or "/home/${username}";
      dotfilesPath = userCfg.dotfilesPath;
      zshrcPath = "${dotfilesPath}/core/zshrc";
    in
    ''
      # Create symlink for ${username}
      if [ -e ${homeDir}/.zshrc ] && [ ! -L ${homeDir}/.zshrc ]; then
        echo "Warning: ${homeDir}/.zshrc exists and is not a symlink"
        echo "Please back it up and remove it, then run: nixos-rebuild switch"
      elif [ "$(readlink ${homeDir}/.zshrc 2>/dev/null)" != "${zshrcPath}" ]; then
        rm -f ${homeDir}/.zshrc
        ln -sf ${zshrcPath} ${homeDir}/.zshrc
        chown ${username}:users ${homeDir}/.zshrc
        echo "Created symlink: ${homeDir}/.zshrc -> ${zshrcPath}"
      fi
    '';

  # Helper to generate declarative zshrc from Nix store
  mkDeclarativeZshrc = username: userCfg:
    let
      homeDir = config.users.users.${username}.home or "/home/${username}";

      # Generate zshrc content that sources from Nix store
      # Single source of truth: just source core/zshrc from dotfiles
      zshrcContent = pkgs.writeText "zshrc-${username}" ''
        # Generated by NixOS zsh-dotfiles module
        # Dotfiles source: ${dotfilesSource}

        # Source core dotfiles configuration (single source of truth)
        source ${dotfilesSource}/core/zshrc

        ${optionalString (userCfg.extraConfig != "") ''
        # NixOS-specific configuration (from extraConfig option)
        # This loads after dotfiles, allowing machine-specific overrides
        ${userCfg.extraConfig}
        ''}
      '';
    in
    ''
      # Setup declarative zshrc for ${username}
      if [ -e ${homeDir}/.zshrc ] && [ ! -L ${homeDir}/.zshrc ]; then
        echo "Warning: ${homeDir}/.zshrc exists and is not a symlink"
        echo "Please back it up and remove it, then run: nixos-rebuild switch"
      else
        rm -f ${homeDir}/.zshrc
        ln -sf ${zshrcContent} ${homeDir}/.zshrc
        chown ${username}:users ${homeDir}/.zshrc
        echo "Created declarative zshrc: ${homeDir}/.zshrc -> Nix store"
      fi
    '';

  enabledUsers = filterAttrs (name: userCfg: userCfg.enable) cfg.users;

in
{
  options.programs.zsh-dotfiles = {
    enable = mkEnableOption "modular zsh dotfiles configuration";

    users = mkOption {
      type = types.attrsOf (types.submodule ({ name, ... }: {
        options = {
          enable = mkOption {
            type = types.bool;
            default = false;
            description = "Enable zsh dotfiles for this user";
          };

          useDeclarative = mkOption {
            type = types.bool;
            default = dotfilesSource != null;
            description = ''
              Use declarative mode (source from Nix store) instead of local clone.
              Defaults to true if dotfilesSource is available from flake.
              Set to false to use local clone mode (requires dotfilesPath).
            '';
          };

          dotfilesPath = mkOption {
            type = types.str;
            default = "/home/${name}/.dotfiles";
            description = ''
              Path to dotfiles repository (only used in local clone mode).
              In declarative mode, dotfiles are sourced from Nix store.
            '';
          };

          extraConfig = mkOption {
            type = types.lines;
            default = "";
            description = ''
              Extra zsh configuration specific to this machine/user.
              This is loaded after dotfiles but before ~/.zshrc.local.
              Use this for NixOS-specific or machine-specific settings.
            '';
            example = ''
              export WORK_DIR="/mnt/work"
              alias rebuild='sudo nixos-rebuild switch --flake /etc/nixos'
            '';
          };
        };
      }));
      default = {};
      description = "Per-user zsh dotfiles configuration";
    };
  };

  config = mkIf cfg.enable {
    # Install required packages system-wide
    environment.systemPackages = with pkgs; [
      zsh
      fzf
      zoxide
      fd
      git
      # Zsh plugins
      zsh-fzf-tab
      zsh-autosuggestions
      zsh-syntax-highlighting
    ];

    # Enable zsh globally
    programs.zsh = {
      enable = true;

      # Don't set a default config - users will have their own via symlink
      # Set up fpath to include plugin directories
      interactiveShellInit = ''
        # Add plugin paths to fpath for detection by core/zshrc
        fpath+=(${pkgs.zsh-fzf-tab}/share/fzf-tab)
        fpath+=(${pkgs.zsh-autosuggestions}/share/zsh-autosuggestions)
        fpath+=(${pkgs.zsh-syntax-highlighting}/share/zsh-syntax-highlighting)
      '';
    };

    # Create symlinks for enabled users via activation script
    system.activationScripts.zsh-dotfiles-symlinks = lib.mkIf (enabledUsers != {}) {
      text = concatStringsSep "\n" (
        mapAttrsToList (username: userCfg:
          if userCfg.useDeclarative && dotfilesSource != null
          then mkDeclarativeZshrc username userCfg
          else mkUserSymlink username userCfg
        ) enabledUsers
      );
      deps = [ ];
    };

    # Set zsh as default shell for enabled users
    users.users = mkMerge (
      mapAttrsToList (username: userCfg:
        mkIf userCfg.enable {
          ${username}.shell = pkgs.zsh;
        }
      ) enabledUsers
    );
  };
}
