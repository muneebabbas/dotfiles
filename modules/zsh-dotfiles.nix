# NixOS module for zsh-dotfiles
# Provides declarative zsh configuration sourced from the Nix store
#
# Usage in your flake.nix:
#   programs.zsh-dotfiles = {
#     enable = true;
#     users.yourusername.enable = true;
#   };
#
# The dotfiles source is automatically provided by the flake.

# This is a "closure" pattern - the outer function receives dotfilesSource from
# flake.nix, then returns the actual NixOS module function.
{ dotfilesSource }:

{ config, lib, pkgs, ... }:

# 'with lib' brings all lib functions into scope (mkOption, types, mkIf, etc.)
with lib;

let
  # cfg is a shorthand to access our module's configuration
  cfg = config.programs.zsh-dotfiles;

  # Generate the zshrc content for a user
  # pkgs.writeText creates a file in the Nix store with the given content
  mkDeclarativeZshrc = username: userCfg:
    let
      # Get user's home directory from NixOS user config, with fallback
      homeDir = config.users.users.${username}.home or "/home/${username}";

      # Create a zshrc file in the Nix store that sources our dotfiles
      zshrcContent = pkgs.writeText "zshrc-${username}" ''
        # Generated by NixOS zsh-dotfiles module
        # Dotfiles source: ${dotfilesSource}

        # Source core dotfiles configuration (single source of truth)
        source ${dotfilesSource}/core/zshrc

        ${optionalString (userCfg.extraConfig != "") ''
        # NixOS-specific configuration (from extraConfig option)
        # This loads after dotfiles, allowing machine-specific overrides
        ${userCfg.extraConfig}
        ''}
      '';
    in
    # This bash script runs during NixOS activation (nixos-rebuild switch)
    # It creates a symlink from ~/.zshrc to the generated file in the Nix store
    ''
      # Setup declarative zshrc for ${username}
      if [ -e ${homeDir}/.zshrc ] && [ ! -L ${homeDir}/.zshrc ]; then
        echo "Warning: ${homeDir}/.zshrc exists and is not a symlink"
        echo "Please back it up and remove it, then run: nixos-rebuild switch"
      else
        rm -f ${homeDir}/.zshrc
        ln -sf ${zshrcContent} ${homeDir}/.zshrc
        echo "Created declarative zshrc: ${homeDir}/.zshrc -> Nix store"
      fi
    '';

  # filterAttrs filters an attribute set, keeping only entries where the predicate is true
  # Here we get only users that have enable = true
  enabledUsers = filterAttrs (name: userCfg: userCfg.enable) cfg.users;

in
{
  # Module options define what users can configure
  options.programs.zsh-dotfiles = {
    # mkEnableOption creates a boolean option with a standard description
    enable = mkEnableOption "modular zsh dotfiles configuration";

    # Per-user configuration using types.attrsOf for a map of username -> config
    users = mkOption {
      type = types.attrsOf (types.submodule ({ name, ... }: {
        options = {
          enable = mkOption {
            type = types.bool;
            default = false;
            description = "Enable zsh dotfiles for this user";
          };

          extraConfig = mkOption {
            type = types.lines;
            default = "";
            description = ''
              Extra zsh configuration specific to this machine/user.
              This is loaded after dotfiles but before ~/.zshrc.local.
              Use this for NixOS-specific or machine-specific settings.
            '';
            example = ''
              export WORK_DIR="/mnt/work"
              alias rebuild='sudo nixos-rebuild switch --flake /etc/nixos'
            '';
          };
        };
      }));
      default = {};
      description = "Per-user zsh dotfiles configuration";
    };
  };

  # mkIf makes this entire config block conditional on cfg.enable being true
  config = mkIf cfg.enable {
    # Install required packages system-wide
    environment.systemPackages = with pkgs; [
      zsh
      fzf
      zoxide
      fd
      git
      # Zsh plugins from nixpkgs (no git clones needed)
      zsh-fzf-tab
      zsh-autosuggestions
      zsh-syntax-highlighting
    ];

    # Enable zsh globally and configure plugin paths
    programs.zsh = {
      enable = true;

      # interactiveShellInit runs for all interactive zsh sessions
      # We add plugin directories to fpath so core/zshrc can detect them
      interactiveShellInit = ''
        # Add plugin paths to fpath for detection by core/zshrc
        # The core/zshrc checks fpath to determine if plugins are available
        fpath+=(${pkgs.zsh-fzf-tab}/share/fzf-tab)
        fpath+=(${pkgs.zsh-autosuggestions}/share/zsh-autosuggestions)
        fpath+=(${pkgs.zsh-syntax-highlighting}/share/zsh-syntax-highlighting)
      '';
    };

    # system.activationScripts runs during nixos-rebuild switch
    # mkIf ensures this only runs if there are enabled users
    system.activationScripts.zsh-dotfiles-symlinks = lib.mkIf (enabledUsers != {}) {
      # concatStringsSep joins strings with a separator
      # mapAttrsToList converts an attrset to a list by applying a function to each key-value pair
      text = concatStringsSep "\n" (
        mapAttrsToList (username: userCfg:
          mkDeclarativeZshrc username userCfg
        ) enabledUsers
      );
      deps = [ ];
    };

    # Set zsh as default shell for enabled users
    # mkMerge combines multiple attribute sets into one
    users.users = mkMerge (
      mapAttrsToList (username: userCfg:
        # mkIf makes each user's shell setting conditional
        mkIf userCfg.enable {
          ${username}.shell = pkgs.zsh;
        }
      ) enabledUsers
    );
  };
}
